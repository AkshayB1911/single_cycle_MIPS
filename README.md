# Single-Cycle MIPS Processor – Group 5

> A basic single-cycle MIPS CPU built in Verilog. No pipelining, just straight execution.

## 🗂️ Files

| File | Description |
|------|-------------|
| `lab_8_group_5.v` | Top-level module (`finall`) and all internal modules. |
| `lab_8_group_5_tb.v` | Testbench with memory preloading and waveform generation. |

## 🚀 Quick Start (Icarus + GTKWave)

```bash
# Compile the design and testbench
iverilog -g2012 -o mips.out lab_8_group_5_tb.v lab_8_group_5.v

# Run the simulation
vvp mips.out

# View waveforms (optional)
gtkwave dump.vcd
```

> *Other simulators like ModelSim, Verilator etc. work too — `dump.vcd` is generated by default.*

```

## 🔧 Modules

- **`signextend`**: Extends 16-bit immediates to 32-bit (signed).
- **`register32`**: 32-bit register used for PC and other internal state.
- **`instruction_memory`**: 256×32 memory for instructions. Acts like ROM after preload.
- **`data_memory`**: 256×32 RAM. Used for load/store instructions.
- **`register_file`**: 32×32 register file with two read ports and one write port.
- **`alu`**: 32-bit ALU that performs arithmetic and logic operations.
- **`control`**: Main controller based on opcode.
- **`alucontrol`**: Secondary control for R-type instructions.
- **`program_counter`**: Handles PC updates with support for branching and jumping.
- **`finall`**: Top-level module that connects everything.

### `finall` Top-Level Ports

| Port | Dir | Description |
|------|-----|-------------|
| `clk` | in | Clock signal |
| `reset` | in | Async reset |
| `rst` | in | Sync reset for PC |
| `load_memory` | in | Enables memory preload |
| `instr_mem_input[31:0]` | in | Instruction to load |
| `data_mem_input[31:0]` | in | Data to load |
| `mem_addr_select_instr[7:0]` | in | Address for instruction memory |
| `mem_addr_select_data[7:0]` | in | Address for data memory |

## ✅ Supported Instructions

| Type | Mnemonic | Opcode/Funct | Description |
|------|----------|--------------|-------------|
| R | `add` | `000000` / `100000` | Add |
| R | `sub` | `000000` / `100010` | Subtract |
| R | `and` | `000000` / `100100` | Bitwise AND |
| R | `or`  | `000000` / `100101` | Bitwise OR |
| R | `slt` | `000000` / `101010` | Set if less than |
| I | `lw`  | `100011` | Load word |
| I | `sw`  | `101011` | Store word |
| I | `beq` | `000100` | Branch if equal |
| J | `j`   | `000010` | Jump |
| J | `jal` | `000011` | Jump and link (stores PC+4 in `$ra`) |

> *More instructions like `addi` can be added by extending control logic.*

## 🧪 Simulation Tips

- Set `load_memory = 1` while loading instructions/data.
- After loading, set `load_memory = 0` and let the processor run.
- Waveform is written to `dump.vcd` for inspection using GTKWave.

## 🏗️ Synthesis

- Written in synthesizable Verilog‑2001.
- Should work on most FPGAs with ≥ ~2k LUTs and at least two dual-port BRAMs.
- Compatible with tools like Quartus, Vivado, and Diamond.

## 📜 License

[MIT License](LICENSE)

---

> *Made by Group 5, IIT Guwahati — because documentation is also part of the project 🙂*
